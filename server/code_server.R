output$insertQ3 <- renderUI({
  fluidPage(
    h5("3. Was any part of the data analysis reported in the manuscript (including data pre-processing) undertaken using code or scripts?"),
    h6("Common examples include custom scripts written using R, STATA, Matlab, Python, SPSS syntax, Excel macros, or generated by any other programmes that process or analyse data."),
    h6("If the manuscript reports using custom analysis code, and this section is not completed then the journal will be unable to progress your submission."),
    
    pickerInput(
      inputId = "Q3",
      label = "",
      choices = c("Yes", "No"),
      selected = isolate(codeValues$Q3),
      multiple = FALSE,
      options = list(title = "Response required"),
    ),
    br(),
    
    uiOutput("insertQ3a"),
  )
})

observeEvent(input$Q3, {
  if (input$Q3 == "Yes") {
    codeValues$codeYes = 1
    codeValues$Q3 = "Yes"
    fullReport$S3_complete = 0

  } else if (input$Q3 == "No"){
    codeValues$codeYes = 2
    codeValues$Q3 = "No"
    fullReport$S3_complete = 1
    fullReport$S3_output = "A"
  }
})

output$insertQ3a <- renderUI({
  if (codeValues$codeYes == 1) {
  #if (codeValues$Q3 == "Yes") {
    fluidPage(
      ## Question 3a
      h5(
        "3a. Select all the relevant types of analysis code for all studies in the manuscript."
      ),
      pickerInput(
        inputId = "Q3a",
        width = "300px",
        label = "",
        choices = codeTypes,
        #selected = isolate(codeValues$Q3a),
        selected = isolate(codeValues$selectedCodeTypes),
        multiple = TRUE,
        options = list(
          "live-search" = TRUE,
          "selected-text-format" = "count",
          "title" = "Code types"
        )
      ),
      div(
        style = "display: inline-block;",
        actionButton("newCode", icon("folder-plus"), style = "color: #1D89FF; background-color: white; border-color: white; font-size: 18px")
      ),
      div(style = "display: inline-block;", h6(
        "Add a type of analysis code that is not listed above"
      )),
       br()
    )
  }
})

observeEvent(input$next3a, {
  if (input$Q3 == "" |
      #(length(codeValues$selectedCodeTypes) == 0 &
      (length(input$Q3a) == 0 &
       codeValues$codeYes == 1)) {
    sendSweetAlert(session = session,
                   title = "Incomplete section",
                   type = "error")
    fullReport$S3_complete = 0
  }
  
  if (codeValues$codeYes == 2) {
    # sendSweetAlert(
    #   session = session, html = TRUE,
    #   title = "Section successfully completed!", 
    #   text = tagList(
    #     "Download your session responses to avoid potential data loss.",
    #     downloadBttn(
    #       outputId = "downloadRDS"
    #     )
    #   ),
    #   type = "success"
    # )
    updateTabsetPanel(session, "sidebar", selected = "materials")
    
  }
  
  if ((length(codeValues$selectedCodeTypes) > 0 &
      codeValues$codeYes == 1)) {
    codeValues$S3a_complete = 1
    
    # sendSweetAlert(
    #   session = session, html = TRUE,
    #   title = "Data save reminder", 
    #   text = tagList(
    #     "You will now proceed to the next subsection. 
    #     You can download your session responses now if you wish to pause or continue
    #     to the end of this Standard.",
    #     downloadBttn(
    #       outputId = "downloadRDS"
    #     )
    #   ),
    #   type = "info"
    # )
    updateTabsetPanel(session, "S3_box", selected = "tab3b")
    
  }
  
})

output$insertQ3b <- renderUI({
  if (codeValues$codeYes == 1) {
    fluidPage(
      h5(
        "3b. Please indicate the public availability for all selected types of analysis code, as explained below."
      ),
      tags$div(
        HTML(
          "<dl>
             <dt>Public availability:</dt>
              <dd>- For all analysis code you first need to indicate whether ALL, SOME or NO code is publicly available.</dd>
             <dt>Availability barrier:</dt>
              <dd>- If ALL code is publicly available, please select the option 'N/A - ALL code is publicly available'.</dd>
              <dd>- If SOME or NO code is publicly available, you need to specify the reason(s), such as an ethical barrier.</dd>
             <dt>Public access route:</dt>
              <dd> - If SOME or ALL code is publicly available without any restrictions, please indicate how readers can access them. For repositories (e.g. OSF) we ask that you provide a valid URL.</dd>
              <dd> - If NO code is publicly available, you should select the option 'N/A - NO code is publicly available'.</dd>
              </dl>"
        )
      ),
      h5(
        "You can copy and paste cell contents for same responses (e.g. URL). Please use the exact address from your browser when adding any URLs (e.g. https://osf.io/9f6gx/)."
      ),
      br(),
      rHandsontableOutput("Q3b"),
      br()
    )
  }
})

observeEvent(input$Q3a, {
  fullReport$S3_complete = 0
  
  codeValues$selectedCodeTypes <- input$Q3a
  
  # if outputs were previously saved
  if (!is.null(codeValues$saveQ3b)){
    codeTable1 <- data.frame(codeValues$Q3b)
    codeValues$saveQ3b = NULL # set saveQ3b to null to allow changes to be made after reloading data
    
  } else {
    codeTable1 <- data.frame(matrix(ncol = 5, nrow = 1))
    codeTable1[1:5] <- NA_character_
    codeTable1[1:length(codeValues$selectedCodeTypes), 1] <-
      as.character(codeValues$selectedCodeTypes)
  }
  
  output$Q3b <- renderRHandsontable({
    if (!is.null(input$Q3b)) {
      codeValues$Q3b = hot_to_r(input$Q3b)
      
      if (all(is.na(codeValues$Q3b[, 2:5])) == TRUE) {
        DF <- codeTable1
      } else if (all(is.na(codeValues$Q3b[, 2:5])) == FALSE &
                 length(setdiff(
                   as.vector(codeValues$selectedCodeTypes),
                   as.vector(codeValues$Q3b$X1)
                 )) == 0) {
        DF <- codeValues$Q3b
        DF <-
          subset(DF,
                 DF$X1 %in% as.vector(codeValues$selectedCodeTypes))
      } else if (all(is.na(codeValues$Q3b[, 2:5])) == FALSE &
                 length(setdiff(
                   as.vector(codeValues$selectedCodeTypes),
                   as.vector(codeValues$Q3b$X1)
                 )) > 0) {
        new_cats <-
          setdiff(as.vector(codeValues$selectedCodeTypes),
                  as.vector(codeValues$Q3b$X1))
        DF <- codeValues$Q3b
        #Big difference here so need to test if this works
        row1 <- nrow(DF) + 1
        
        DF[row1, 1] <- new_cats
      }
    } else {
      DF <- codeTable1
    }
    
    rhandsontable(
      DF,
      useTypes = TRUE,
      stretchH = "all",
      height = 300,
      colHeaders = c(
        "Code type",
        "Public availability",
        "Availability barrier",
        "Public access route",
        "URL (if applicable)"
      )
    ) %>%
      hot_context_menu(allowRowEdit = FALSE, allowColEdit = FALSE) %>%
      hot_col(col = "Code type",
              readOnly = TRUE,
              allowInvalid = FALSE) %>%
      hot_col(
        col = "Public availability",
        type = "dropdown",
        allowInvalid = FALSE,
        source = c(
          "ALL code is publicly available",
          "SOME code is publicly available",
          "NO code is publicly available"
        )
      ) %>%
      hot_col(
        col = "Availability barrier",
        type = "dropdown",
        source = codeReason,
        allowInvalid = FALSE
      ) %>%
      hot_col(
        col = "Public access route",
        type = "dropdown",
        source = codePublic,
        allowInvalid = FALSE
      ) %>%
      hot_cols(colWidths = c(200, 225, 250, 250, 120))
  })

})

# Observe input for additional data types (button click)

observeEvent(input$newCode, {
  # Pop up with text input
  inputSweetAlert(
    session,
    inputId = "addCode",
    title = "Add a new unlisted type of analysis code",
    text = "Please use abbreviations where possible (if included in the manuscript).",
    input = "text",
    type = "info"
  )
})

# Add user's responses to the list and update it
observeEvent(input$addCode, {
  codeValues$codeTypes <- c(codeValues$codeTypes, input$addCode)
  
  updatePickerInput(
    session,
    inputId = "Q3a",
    label = "",
    choices = codeValues$codeTypes,
    selected = isolate(codeValues$Q3a)
    
  )
})

# Back buttons  ---------------------------------------------------------------------

observeEvent(input$previous3b,
             {
               updateTabsetPanel(session, "S3_box", selected = "tab3a")
             })

observeEvent(input$previous3c,
             {
               updateTabsetPanel(session, "S3_box", selected = "tab3b")
             })

observeEvent(input$next3b, {
  show_modal_spinner(spin = "orbit",
                     color = "purple",
                     text = "Checking your responses...")
  ## Convert table input into an R object
  codeValues$Q3b <- hot_to_r(input$Q3b)
  
  ## Convert all factors into characters
  codeValues$Q3b[] <- lapply(codeValues$Q3b, as.character)
  
  ## Check whether any URLs exist
  
  codeValues$Q3b$exists <-
    ifelse(is_valid_url(codeValues$Q3b[5]) == TRUE, "valid", "invalid")
  
  if ("valid" %in% codeValues$Q3b) {
    url_validity <- data.frame(matrix(ncol = 2))
    url_validity[1] <-
      codeValues$Q3b$X5[codeValues$Q3b$exists == "valid"]
    url_validity[2] <-
      !ldply(codeValues$Q3b$X5[codeValues$Q3b$exists == "valid"], http_error)
    
    url_valid <- subset(url_validity, url_validity[2] == TRUE)
    url_invalid <- subset(url_validity, url_validity[2] == FALSE)
    
    codeValues$Q3b$exists <-
      ifelse(
        codeValues$Q3b$exists == "valid" &
          codeValues$Q3b[5] %in% url_valid,
        "TRUE",
        ifelse(
          codeValues$Q3b$exists == "valid" &
            codeValues$Q3b[5] %in% url_invalid,
          "FALSE",
          "FALSE"
        )
      )
  } else {
    codeValues$Q3b$exists <-
      ifelse(codeValues$Q3b$exists == "invalid", "FALSE", "NA")
  }
  
  ## Conditions for errors, warnings and successful completion
  codeValues$Q3b$condition <- if_else(
    is.na(codeValues$Q3b[2]) |
      is.na(codeValues$Q3b[3]) | is.na(codeValues$Q3b[4]),
    "incomplete",
    if_else(
      is.na(codeValues$Q3b[5]) &
        codeValues$Q3b[4] == "Code in repository (URL required)",
      "url_miss",
      if_else(
        codeValues$Q3b[4] == "Code is contained in the paper",
        "manuscript",
        if_else(
          codeValues$Q3b[3] == "Technical barrier only" |
            codeValues$Q3b[3] == "Author preference",
          "invalid_barrier",
          if_else(
            codeValues$Q3b[6] == "FALSE" &
              codeValues$Q3b[4] == "Code in repository (URL required)",
            "invalid_url",
            "success"
          )
        )
      )
    )
  )
  

  codeValues$Q3b$inconsistency <- if_else(
    codeValues$Q3b[2] == "ALL code is publicly available" &
      (
        codeValues$Q3b[3] != "N/A - ALL code is publicly available" |
          codeValues$Q3b[4] == "N/A - NO code is publicly available"
      ),
    "inconsistent_all",
    if_else(
      codeValues$Q3b[2] == "SOME code is publicly available" &
        (
          codeValues$Q3b[3] == "N/A - ALL code is publicly available" |
            codeValues$Q3b[4] == "N/A - NO code is publicly available"
        ),
      "inconsistent_some",
      if_else(
        codeValues$Q3b[2] == "NO code is publicly available" &
          (
            codeValues$Q3b[3] == "N/A - ALL code is publicly available" |
              codeValues$Q3b[4] != "N/A - NO code is publicly available"
          ),
        "inconsistent_no",
        "success"
      )
    )
  )

  codeValues$Q3b_partialCode <-
    ifelse("SOME code is publicly available" %in% codeValues$Q3b$X2, 1, 2)
  codeValues$Q3b_noneCode <-
    ifelse("NO code is publicly available" %in% codeValues$Q3b$X2, 1, 2)
  
  codeValues$Q3b_invalidrepo <-
    ifelse(TRUE %in% str_contains(
      codeValues$Q3b$X5,
      c("drive", "google", "dropbox"),
      ignore.case = TRUE
    ),
    1,
    2)
  
  ## Save URLs that don't exist to present in an alert later on when user tries to proceed
  codeValues$Q3b_urls <-
    unique(codeValues$Q3b$X5[codeValues$Q3b$condition == "invalid_url"])
  
  codeValues$Q3b_incomplete <-
    ifelse("incomplete" %in% codeValues$Q3b$condition, 1, 2)
  codeValues$Q3b_urlmiss <-
    ifelse("url_miss" %in% codeValues$Q3b$condition, 1, 2)
  codeValues$Q3b_manuscript <-
    ifelse("manuscript" %in% codeValues$Q3b$condition, 1, 2)
  codeValues$Q3b_invalid_url <-
    ifelse("invalid_url" %in% codeValues$Q3b$condition, 1, 2)
  codeValues$Q3b_invalid_barrier <-
    ifelse("invalid_barrier" %in% codeValues$Q3b$condition, 1, 2)
  
  codeValues$Q3b_inconsistent_all <-
    ifelse("inconsistent_all" %in% codeValues$Q3b$inconsistency, 1, 2)
  codeValues$Q3b_inconsistent_some <-
    ifelse("inconsistent_some" %in% codeValues$Q3b$inconsistency, 1, 2)
  codeValues$Q3b_inconsistent_no <-
    ifelse("inconsistent_no" %in% codeValues$Q3b$inconsistency, 1, 2)
  
  # 1. Incomplete section (empty table or missing responses)
  
  if (is.null(input$Q3b) | codeValues$Q3b_incomplete < 2) {
    codeValues$warning_incomplete_Q3b = 1
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Incomplete section",
      text = "You have not completed this section (there are missing responses or unanswered questions).",
      type = "error"
    )
  } else if (!is.null(input$Q3b) & codeValues$Q3b_incomplete == 2) {
    codeValues$warning_incomplete_Q3b = 2
  }
  
  # 2. Missed URL when repository is specified
  if (codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 1) {
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Missing URL",
      text = "A URL is required if you have indicated that publicly available code is archived in a repository.",
      type = "error"
    )
  }
  
  # 3. Code is in the manuscript and authors haven't yet confirmed the pop-up
  if (codeValues$Q3b_manuscript == 1 &
      (is.null(input$manuscriptOkQ3b) |
       isFALSE(input$manuscriptOkQ3b)) &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2) {
    codeValues$Q3b_complete = 0
    
    codeValues$warning_manuscript = 1
    confirmSweetAlert(
      session = session,
      inputId = "manuscriptOkQ3b",
      type = "warning",
      title = "Warning",
      text = "Do you confirm that the manuscript contains all analysis code?
        If this is NOT the case, the journal will be unable to progress your submission.",
      btn_labels = c("No", "Yes")
    )
  } else if (codeValues$Q3b_manuscript == 1 &
             isTRUE(input$manuscriptOkQ3b) &
             codeValues$warning_incomplete_Q3b == 2 &
             codeValues$Q3b_urlmiss == 2) {
    codeValues$warning_manuscript = 2
  }
  
  
  # 4. There is an invalid barrier and they haven't confirmed they have approval from the editor
  if (codeValues$Q3b_invalid_barrier == 1 &
      (is.null(input$barrierApprovalQ3b) |
       isFALSE(input$barrierApprovalQ3b)) &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2 &
      (codeValues$warning_manuscript == 2 |
       codeValues$warning_manuscript == 0)) {
    codeValues$Q3b_complete = 0
    
    codeValues$warning_invalid_barrier = 1
    fullReport$editor$Note[3] <- "No"
    
    confirmSweetAlert(
      session = session,
      inputId = "barrierApprovalQ3b",
      title = "Warning",
      text = "If you have selected 'Technical barrier only' or 'Author preference' please note that these
      reasons are generally not an eligible basis for restricting public availability of analysis code.
      Do you confirm that you have selected them only following editorial approval?",
      type = "warning",
      btn_labels = c("No", "Yes")
    )
  } else if (codeValues$Q3b_invalid_barrier == 1 &
             isTRUE(input$barrierApprovalQ3b) &
             codeValues$warning_incomplete_Q3b == 2 &
             codeValues$Q3b_urlmiss == 2 &
             (codeValues$warning_manuscript == 2 |
              codeValues$warning_manuscript == 0)) {
    codeValues$warning_invalid_barrier = 2
    fullReport$editor$Note[3] <- "Yes"
  }

    # 5. Invalid repositories
  if (codeValues$Q3b_invalidrepo == 1 &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2 &
      (codeValues$warning_manuscript == 2 |
       codeValues$warning_manuscript == 0) &
      (codeValues$warning_invalid_barrier == 0 |
       codeValues$warning_invalid_barrier == 2)) {
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Invalid repository",
      text = "Google Drive and Dropbox are not considered valid repositories for public archiving of code.",
      type = "error"
    )
  }
  
  # 6. Invalid URLs
  if (codeValues$Q3b_invalid_url == 1 &
      codeValues$Q3b_invalidrepo == 2 &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2 &
      (codeValues$warning_manuscript == 2 |
       codeValues$warning_manuscript == 0) &
      (codeValues$warning_invalid_barrier == 0 |
       codeValues$warning_invalid_barrier == 2)) {
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "The following URLs are invalid:",
      text = codeValues$Q3b_urls,
      type = "warning"
    )
  }
  
  # 7. Inconsistent responses - ALL
  if (codeValues$Q3b_inconsistent_all == 1 &
      codeValues$Q3b_invalid_url == 2 &
      codeValues$Q3b_invalidrepo == 2 &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2
      &
      (codeValues$warning_manuscript == 2 |
       codeValues$warning_manuscript == 0) &
      (codeValues$warning_invalid_barrier == 0 |
       codeValues$warning_invalid_barrier == 2)) {
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Inconsistent responses",
      text = "You have selected that ALL code is publicly available but your other responses do not match -
      make sure that 'N/A - ALL code is publicly available' is selected where applicable and that a valid public access route is chosen.",
      type = "error"
    )
  }
  
  # 8. Inconsistent responses - SOME
  if (codeValues$Q3b_inconsistent_some == 1 &
      codeValues$Q3b_inconsistent_all == 2 &
      codeValues$Q3b_invalid_url == 2 &
      codeValues$Q3b_invalidrepo == 2 &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2
      &
      (codeValues$warning_manuscript == 2 |
       codeValues$warning_manuscript == 0) &
      (codeValues$warning_invalid_barrier == 0 |
       codeValues$warning_invalid_barrier == 2)) {
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Inconsistent responses",
      text = "You have selected that SOME code is publicly available but your other responses do not match -
      for example, you might have selected the option 'N/A - ALL code is publicly available'.",
      type = "error"
    )
  }

  # 9. Inconsistent responses - NONE
  if (codeValues$Q3b_inconsistent_no == 1 &
      codeValues$Q3b_inconsistent_some == 2 &
      codeValues$Q3b_inconsistent_all == 2 &
      codeValues$Q3b_invalid_url == 2 &
      codeValues$Q3b_invalidrepo == 2 &
      codeValues$warning_incomplete_Q3b == 2 &
      codeValues$Q3b_urlmiss == 2
      &
      (codeValues$warning_manuscript == 2 |
       codeValues$warning_manuscript == 0) &
      (codeValues$warning_invalid_barrier == 0 |
       codeValues$warning_invalid_barrier == 2)) {
    codeValues$Q3b_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Inconsistent responses",
      text = "You have selected that NO code is publicly available but your other responses do not match -
      for example, you might have selected the option 'N/A - ALL code is publicly available'.",
      type = "error"
    )
  } else if (codeValues$Q3b_inconsistent_no == 2 &
             codeValues$Q3b_inconsistent_some == 2 &
             codeValues$Q3b_inconsistent_all == 2 &
             codeValues$Q3b_invalid_url == 2 &
             codeValues$Q3b_invalidrepo == 2 &
             codeValues$warning_incomplete_Q3b == 2 &
             codeValues$Q3b_urlmiss == 2
             &
             (codeValues$warning_manuscript == 2 |
              codeValues$warning_manuscript == 0) &
             (codeValues$warning_invalid_barrier == 0 |
              codeValues$warning_invalid_barrier == 2)) {
    codeValues$Q3b_complete = 1
    
    fullReport$S3_table1 = codeValues$Q3b[, 1:5]
    names(fullReport$S3_table1) <- c(
      "Code type",
      "Public availability",
      "Availability barrier",
      "Public access route",
      "URL"
    )
    
    fullReport$S3_table1[2] <-
      ifelse(
        fullReport$S3_table1[2] == "ALL code is publicly available",
        "ALL code",
        ifelse(
          fullReport$S3_table1[2] == "SOME code is publicly available",
          "SOME code",
          "NO code"
        )
      )
    
    fullReport$S3_table1[3]  <-
      ifelse(
        fullReport$S3_table1[3] == "N/A - ALL code is publicly available",
        "NA",
        fullReport$S3_table1$`Availability barrier`
      )
    
    fullReport$S3_table1[4]  <-
      ifelse(
        fullReport$S3_table1[4] == "N/A - NO code is publicly available",
        "NA",
        fullReport$S3_table1$`Public access route`
      )
    
    fullReport$S3_table3 <- subset(fullReport$S3_table1, select = c(1, 4:5))
    
    if (isTRUE(levels(as.factor(fullReport$S3_table1[[2]]))=="ALL code")) {
      fullReport$S3_output = "B"
    }
  }
  remove_modal_spinner()

  ##Code for partial/no availability
  
  if (codeValues$Q3b_complete == 1 &
      codeValues$Q3b_partialCode == 2 &
      codeValues$Q3b_noneCode == 2) {
    codeValues$S3b_complete = 1
    # sendSweetAlert(
    #   session = session, 
    #   title = "Section successfully completed!", 
    #   html = TRUE,
    #   text = tagList(
    #     "Download your session responses to avoid potential data loss.",
    #     downloadBttn(
    #       outputId = "downloadRDS"
    #     )
    #   ),
    #   type = "success"
    # )
    updateTabsetPanel(session, "sidebar", selected = "materials")
    fullReport$S3_complete = 1
    fullReport$S3_output = "B"
  }
  
  if (codeValues$Q3b_complete == 1 &
      (codeValues$Q3b_partialCode == 1 |
       codeValues$Q3b_noneCode == 1)) {
    codeValues$partialCodeTypes <-
      subset(
        codeValues$Q3b,
        codeValues$Q3b$X2 != "ALL code is publicly available",
        select = 1:2)
    
    

    if (!is.null(codeValues$saveQ3c)){
      codeTable1 <- data.frame(codeValues$Q3c)
      codeValues$saveQ3c = NULL # set saveQ3c to null to allow changes to be made after reloading data
      
    } else {
      
      codeTable1 <- data.frame(matrix(ncol = 4, nrow = 1))
      codeTable1[1:4] <- NA_character_
      codeTable1[1:nrow(codeValues$partialCodeTypes), 1] <-
        as.character(codeValues$partialCodeTypes$X1)
      
      codeTable1[1:nrow(codeValues$partialCodeTypes), 2] <-
        as.character(codeValues$partialCodeTypes$X2)
      
      codeTable1$X2 <-
        if_else(
          codeTable1$X2 == "NO code is publicly available",
          "NO code",
          if_else(
            codeTable1$X2 == "SOME code is publicly available",
            "SOME code",
            "NA"
          )
        )
    }
    
    output$Q3c <- renderRHandsontable({
      if (!is.null(input$Q3c)) {
        codeValues$Q3c = hot_to_r(input$Q3c)
        
        if (all(is.na(codeValues$Q3c[, 2:4])) == TRUE) {
          DF <- codeTable1
        } else if (all(is.na(codeValues$Q3c[, 2:4])) == FALSE &
                   length(setdiff(
                     codeValues$partialCodeTypes$X1,
                     as.vector(codeValues$Q3c$X1)
                   )) == 0) {
          DF <- codeValues$Q3c
          DF <-
            subset(DF,
                   DF$X1 %in% as.vector(codeValues$partialCodeTypes$X1))
        } else if (all(is.na(codeValues$Q3c[, 2:4])) == FALSE &
                   length(setdiff(
                     as.vector(codeValues$partialCodeTypes$X1),
                     as.vector(codeValues$Q3c$X1)
                   )) > 0) {
          new_cats <-
            setdiff(
              as.vector(codeValues$partialCodeTypes$X1),
              as.vector(codeValues$Q3c$X1)
            )
          DF <- codeValues$Q3c
          row1 <- nrow(DF) + 1
          DF[row1, 1] <- new_cats
        }
      }
      else
      {
        DF <- codeTable1
      }
      
      rhandsontable(
        DF,
        useTypes = TRUE,
        stretchH = "all",
        height = 200,
        colHeaders = c(
          "Code type",
          "Public availability",
          "Restricted access route",
          "Restricted access conditions"
        )
      ) %>%
        hot_context_menu(allowRowEdit = FALSE, allowColEdit = FALSE) %>%
        hot_col(col = "Code type",
                readOnly = TRUE,
                allowInvalid = FALSE) %>%
        hot_col(col = "Public availability",
                readOnly = TRUE,
                allowInvalid = FALSE) %>%
        
        hot_col(
          col = "Restricted access route",
          type = "dropdown",
          source = codeRestricted,
          allowInvalid = FALSE
        ) %>%
        hot_col(
          col = "Restricted access conditions",
          type = "dropdown",
          source = codeCondition,
          allowInvalid = FALSE
        ) %>%
        hot_cols(colWidths = c(200, 200, 280, 350))
    })
    codeValues$S3b_complete = 1
    # sendSweetAlert(
    #   session = session, html = TRUE,
    #   title = "Data save reminder", 
    #   text = tagList(
    #     "You will now proceed to the next subsection. 
    #     You can download your session responses now if you wish to pause or continue
    #     to the end of this Standard.",
    #     downloadBttn(
    #       outputId = "downloadRDS"
    #     )
    #   ),
    #   type = "info"
    # )
    updateTabsetPanel(session, "S3_box", selected = "tab3c")
    fullReport$S3_complete = 0
    
  }
  
})

output$insertQ3c <- renderUI({
  req(input$Q3b)
  
  if (codeValues$Q3b_complete == 1 &
      (codeValues$Q3b_partialCode == 1 |
       codeValues$Q3b_noneCode == 1)) {
    fluidPage(
      h5(
        "3c. You have indicated partial and/or no public availability for your code type(s). In this table please explain how readers
         can access the code that is not publicly available (restricted access route) and under what conditions they can do so (restricted
         access conditions)."
      ),
      # p(
      #   em(
      #     "You can copy and paste cell contents for same responses (e.g. URL)."
      #   )
      # ),
      br(),
      rHandsontableOutput("Q3c"),
      br()
    )
  }
})

observeEvent(input$next3c, {
  show_modal_spinner(spin = "orbit",
                     color = "purple",
                     text = "Checking your responses...")
  
  codeValues$Q3c[] <- lapply(codeValues$Q3c, as.character)

  codeValues$Q3c$condition <-
    if_else(is.na(codeValues$Q3c$X3) |
              is.na(codeValues$Q3c$X4),
            "incomplete",
            "na")

  codeValues$Q3c_incomplete <-
    ifelse("incomplete" %in% codeValues$Q3c$condition, 1, 2)
  
  # inconsistent responses
  codeValues$Q3c$inconsistency <-
    if_else((
      codeValues$Q3c$X3 == "Readers can never access the 'restricted' code" &
        codeValues$Q3c$X4 != "Readers can never access the 'restricted' code"
    ) |
      (
        codeValues$Q3c$X3 != "Readers can never access the 'restricted' code" &
          codeValues$Q3c$X4 == "Readers can never access the 'restricted' code"
      ),
    "inconsistent_never",
    if_else(
      codeValues$Q3c$X3 == "Request to ethics committee(s)" &
        codeValues$Q3c$X4 == "Shared unconditionally upon request to author(s)",
      "inconsistent_ethics",
      if_else(
        codeValues$Q3c$X3 == "Request or apply to external authority" &
          codeValues$Q3c$X4 == "Shared unconditionally upon request to author(s)",
        "inconsistent_external",
        "success"
      )
    )
    )

  codeValues$Q3c_inconsistent_never <-
    ifelse("inconsistent_never" %in% codeValues$Q3c$inconsistency, 1, 2)
  codeValues$Q3c_inconsistent_ethics <-
    ifelse("inconsistent_ethics" %in% codeValues$Q3c$inconsistency,
           1,
           2)
  codeValues$Q3c_inconsistent_external <-
    ifelse("inconsistent_external" %in% codeValues$Q3c$inconsistency,
           1,
           2)
  
  # 1. Incomplete section (empty table or missing responses)
  if (is.null(input$Q3c) | codeValues$Q3c_incomplete < 2) {
    codeValues$warning_incomplete_Q3c = 1
    codeValues$Q3c_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Incomplete section",
      text = "You have not completed this section (there are missing responses or unanswered questions).",
      type = "error"
    )
  } else if (!is.null(input$Q3c) & codeValues$Q3c_incomplete == 2) {
    codeValues$warning_incomplete_Q3c = 2
  }

  # 2. Inconsistent responses - never
  
  if (codeValues$Q3c_inconsistent_never == 1 &
      codeValues$warning_incomplete_Q3c == 2) {
    codeValues$Q3c_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Inconsistent responses",
      text = "You have selected that readers can never access the 'restricted' code but your other responses do not match -
      for example, you might have selected a route for restricted access.",
      type = "error"
    )
  }
  
  # 3. Inconsistent responses - ethics
  
  if (codeValues$Q3c_inconsistent_ethics == 1 &
      codeValues$Q3c_inconsistent_never == 2 &
      codeValues$warning_incomplete_Q3c == 2) {
    codeValues$Q3c_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Inconsistent responses",
      text = "You have selected that an approval is required by the ethics committee(s) but that the 'restricted' code can be shared *unconditionally* upon request to authors.
      Please revise your responses to ensure that a valid route for access and corresponding conditions are selected.",
      type = "error"
    )
  }
  
  # 4. Inconsistent responses - external
  
  if (codeValues$Q3c_inconsistent_external == 1 &
      codeValues$Q3c_inconsistent_ethics == 2 &
      codeValues$Q3c_inconsistent_never == 2 &
      codeValues$warning_incomplete_Q3c == 2) {
    codeValues$Q3c_complete = 0
    
    sendSweetAlert(
      session = session,
      title = "Inconsistent responses",
      text = "You have selected that an approval or application to an external authority is required but that the 'restricted' code can be shared *unconditionally* upon request to authors.
      Please revise your responses to ensure that a valid route for access and corresponding conditions are selected.",
      type = "error"
    )
  } else if (codeValues$Q3c_inconsistent_never == 2 &
             codeValues$Q3c_inconsistent_ethics == 2 &
             codeValues$Q3c_inconsistent_never == 2 &
             codeValues$warning_incomplete_Q3c == 2) {
    codeValues$Q3c_complete = 1
    fullReport$S3_complete = 1
    
    if (isTRUE(levels(as.factor(fullReport$S3_table1[[2]]))=="NO code")) {
      fullReport$S3_output = "D"
    } else {
      fullReport$S3_output = "C"
      
    }

    fullReport$S3_table2 <- codeValues$Q3c[1:4]
    names(fullReport$S3_table2) <- c(
      "Code type",
      "Public availability",
      "Restricted access route",
      "Restricted access conditions"
    )
    
    # sendSweetAlert(
    #   session = session,
    #   title = "Section successfully completed!",
    #   html = TRUE,
    #   text = tagList(
    #     "Download your session responses to avoid potential data loss.",
    #     downloadBttn(
    #       outputId = "downloadRDS"
    #     )
    #   ),
    #   type = "success"
    # )
    codeValues$S3c_complete = 1
    
    if (fullReport$S3_output == "D") {
      fullReport$S3_table4 <- fullReport$S3_table2
      fullReport$S3_table4[, 2] <- fullReport$S3_table1[, 3]
    }
    
    updateTabsetPanel(session, "sidebar", selected = "materials")
  }
  remove_modal_spinner()
  
})
